"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArduinoGDBBackend = void 0;
const path = require("path");
const fs = require("arduino-ide-extension/lib/node/fs-extra");
const child_process_1 = require("child_process");
const GDBBackend_1 = require("cdt-gdb-adapter/dist/GDBBackend");
const arduino_parser_1 = require("./arduino-parser");
class ArduinoGDBBackend extends GDBBackend_1.GDBBackend {
    constructor() {
        super();
        this.parser = new arduino_parser_1.ArduinoParser(this);
    }
    spawn(requestArgs) {
        if (!requestArgs.sketch) {
            throw new Error('Missing argument: sketch');
        }
        if (!requestArgs.fqbn) {
            throw new Error('Missing argument: fqbn');
        }
        const sketchFS = fs.statSync(requestArgs.sketch);
        const sketchDir = sketchFS.isFile() ? path.dirname(requestArgs.sketch) : requestArgs.sketch;
        const command = requestArgs.arduinoCli || 'arduino-cli';
        const args = [
            'debug',
            '-p', requestArgs.uploadPort || 'none',
            '-b', requestArgs.fqbn,
            '--interpreter', 'mi2',
            sketchDir
        ];
        const proc = child_process_1.spawn(command, args);
        this.proc = proc;
        this.out = proc.stdin;
        return this.parser.parseFull(proc);
    }
    sendFileExecAndSymbols() {
        // The program file is already sent by `arduino-cli`
        return Promise.resolve();
    }
    sendExecInterrupt(threadId) {
        let command = '-exec-interrupt';
        if (threadId) {
            command += ` --thread ${threadId}`;
        }
        return this.sendCommand(command);
    }
    sendStackInfoFrame(threadId, frameId) {
        const command = `-stack-info-frame --thread ${threadId} --frame ${frameId}`;
        return this.sendCommand(command);
    }
    sendTargetDetach() {
        return this.sendCommand('-target-detach');
    }
    kill() {
        if (!this.proc) {
            return;
        }
        if (process.platform === 'win32') {
            child_process_1.spawn('taskkill', ['/pid', this.proc.pid.toString(), '/f', '/t']);
        }
        else {
            this.proc.kill('SIGKILL');
        }
    }
}
exports.ArduinoGDBBackend = ArduinoGDBBackend;
//# sourceMappingURL=arduino-gdb-backend.js.map