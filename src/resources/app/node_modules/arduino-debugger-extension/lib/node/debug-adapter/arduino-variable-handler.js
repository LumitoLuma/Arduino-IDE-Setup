"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArduinoVariableHandler = void 0;
const path = require("path");
const varManager_1 = require("cdt-gdb-adapter/dist/varManager");
const mi = require("cdt-gdb-adapter/dist/mi");
class ArduinoVariableHandler {
    constructor(session, frameHandles, variableHandles) {
        this.session = session;
        this.frameHandles = frameHandles;
        this.variableHandles = variableHandles;
        this.gdb = session.arduinoBackend;
        this.varMgr = new varManager_1.VarManager(this.gdb);
    }
    createGlobalHandle() {
        this.globalHandle = this.frameHandles.create({
            threadId: -1,
            frameId: -1
        });
    }
    /** TODO */
    getGlobalVariables() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Global variables are not supported yet.');
            const frame = this.frameHandles.get(this.globalHandle);
            const symbolInfo = []; // this.symbolTable.getGlobalVariables();
            const variables = [];
            for (const symbol of symbolInfo) {
                const name = `global_var_${symbol.name}`;
                const variable = yield this.getVariables(frame, name, symbol.name, -1);
                variables.push(variable);
            }
            return variables;
        });
    }
    /** TODO */
    getStaticVariables(frameHandle) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Static variables are not supported yet.');
            const frame = this.frameHandles.get(frameHandle);
            const result = yield this.gdb.sendStackInfoFrame(frame.threadId, frame.frameId);
            const file = path.normalize(result.frame.file || '');
            const symbolInfo = []; // this.symbolTable.getStaticVariables(file);
            const variables = [];
            // Fetch stack depth to obtain frameId/threadId/depth tuple
            const stackDepth = yield mi.sendStackInfoDepth(this.gdb, { maxDepth: 100 });
            const depth = parseInt(stackDepth.depth, 10);
            for (const symbol of symbolInfo) {
                const name = `${file}_static_var_${symbol.name}`;
                const variable = yield this.getVariables(frame, name, symbol.name, depth);
                variables.push(variable);
            }
            return variables;
        });
    }
    getVariables(frame, name, expression, depth) {
        return __awaiter(this, void 0, void 0, function* () {
            let global = this.varMgr.getVar(frame.frameId, frame.threadId, depth, name);
            if (global) {
                // Update value if it is already loaded
                const vup = yield mi.sendVarUpdate(this.gdb, { name });
                const update = vup.changelist[0];
                if (update && update.in_scope === 'true' && update.name === global.varname) {
                    global.value = update.value;
                }
            }
            else {
                // create var in GDB and store it in the varMgr
                const varCreateResponse = yield mi.sendVarCreate(this.gdb, {
                    name,
                    frame: 'current',
                    expression,
                });
                global = this.varMgr.addVar(frame.frameId, frame.threadId, depth, name, true, false, varCreateResponse);
            }
            return {
                name: expression,
                value: (global.value === void 0) ? '<unknown>' : global.value,
                type: global.type,
                variablesReference: parseInt(global.numchild, 10) > 0
                    ? this.variableHandles.create({
                        frameHandle: this.globalHandle,
                        type: 'object',
                        varobjName: global.varname,
                    })
                    : 0,
            };
        });
    }
    handlePinStatusRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            const variables = [];
            variables.push({
                name: "D2",
                type: "gpio",
                value: "0x00",
                variablesReference: 0
            });
            return variables;
        });
    }
}
exports.ArduinoVariableHandler = ArduinoVariableHandler;
//# sourceMappingURL=arduino-variable-handler.js.map