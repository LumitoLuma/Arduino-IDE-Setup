"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const GDBDebugSession_1 = require("cdt-gdb-adapter/dist/GDBDebugSession");
const mi = require("cdt-gdb-adapter/dist/mi");
const arduino_gdb_backend_1 = require("./arduino-gdb-backend");
const arduino_variable_handler_1 = require("./arduino-variable-handler");
const vscode_debugadapter_1 = require("vscode-debugadapter");
const GLOBAL_HANDLE_ID = 0xFE;
const STATIC_HANDLES_START = 0x010000;
const STATIC_HANDLES_FINISH = 0x01FFFF;
class ArduinoDebugSession extends GDBDebugSession_1.GDBDebugSession {
    get arduinoBackend() {
        return this.gdb;
    }
    get variableHandler() {
        if (this._variableHandler) {
            return this._variableHandler;
        }
        if (!this.gdb) {
            throw new Error("GDB backend is not ready.");
        }
        const handler = new arduino_variable_handler_1.ArduinoVariableHandler(this, this.frameHandles, this.variableHandles);
        this._variableHandler = handler;
        return handler;
    }
    createBackend() {
        return new arduino_gdb_backend_1.ArduinoGDBBackend();
    }
    configurationDoneRequest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.gdb.sendCommand('-interpreter-exec console "monitor reset halt"');
                yield mi.sendExecContinue(this.gdb);
                this.sendResponse(response);
            }
            catch (err) {
                this.sendErrorResponse(response, 100, err.message);
            }
        });
    }
    pauseRequest(response, args) {
        if (process.platform === 'win32') {
            const message = 'Pause is not supported on Windows. Please stop the debug session and set a breakpoint instead.';
            this.sendEvent(new vscode_debugadapter_1.OutputEvent(message));
            this.sendErrorResponse(response, 1, message);
            return Promise.resolve();
        }
        return super.pauseRequest(response, args);
    }
    disconnectRequest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.isRunning) {
                    if (process.platform === 'win32') {
                        // We cannot pause on Windows
                        this.arduinoBackend.kill();
                        this.sendResponse(response);
                        return;
                    }
                    // Need to pause first
                    const waitPromise = new Promise(resolve => this.waitPaused = resolve);
                    this.gdb.pause();
                    yield waitPromise;
                }
                yield this.gdb.sendGDBExit();
                this.sendResponse(response);
            }
            catch (err) {
                this.sendErrorResponse(response, 1, err.message);
            }
        });
    }
    scopesRequest(response, args) {
        try {
            const frame = {
                type: 'frame',
                frameHandle: args.frameId,
            };
            // const pins: ObjectVariableReference = {
            //     type: "object",
            //     varobjName: "__pins",
            //     frameHandle: 42000,
            // }
            response.body = {
                scopes: [
                    // new Scope('Pins', this.variableHandles.create(pins), false),
                    new vscode_debugadapter_1.Scope('Local', this.variableHandles.create(frame), false),
                    new vscode_debugadapter_1.Scope('Global', GLOBAL_HANDLE_ID, false),
                ],
            };
            this.sendResponse(response);
        }
        catch (err) {
            this.sendErrorResponse(response, 1, err.message);
        }
    }
    variablesRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                response.body = {
                    variables: []
                };
                const ref = this.variableHandles.get(args.variablesReference);
                if (args.variablesReference === GLOBAL_HANDLE_ID) {
                    // Use hardcoded global handle to load and store global variables
                    response.body.variables = yield this.variableHandler.getGlobalVariables();
                }
                else if (args.variablesReference >= STATIC_HANDLES_START && args.variablesReference <= STATIC_HANDLES_FINISH) {
                    // Use STATIC_HANDLES_START to shift the framehandles back
                    const frameHandle = args.variablesReference - STATIC_HANDLES_START;
                    response.body.variables = yield this.variableHandler.getStaticVariables(frameHandle);
                }
                else if (ref && ref.type === 'frame') {
                    // List variables for current frame
                    response.body.variables = yield this.handleVariableRequestFrame(ref);
                }
                else if (ref && ref.varobjName === '__pins') {
                    response.body.variables = yield this.variableHandler.handlePinStatusRequest();
                }
                else if (ref && ref.type === 'object') {
                    // List data under any variable
                    response.body.variables = yield this.handleVariableRequestObject(ref);
                }
                this.sendResponse(response);
            }
            catch (err) {
                this.sendErrorResponse(response, 1, err.message);
            }
        });
    }
}
exports.ArduinoDebugSession = ArduinoDebugSession;
//# sourceMappingURL=arduino-debug-session.js.map