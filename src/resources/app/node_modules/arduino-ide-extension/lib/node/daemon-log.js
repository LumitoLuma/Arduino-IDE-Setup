"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("@theia/core/lib/common/logger");
var DaemonLog;
(function (DaemonLog) {
    var Url;
    (function (Url) {
        function is(arg) {
            return !!arg
                && typeof arg.Scheme === 'string'
                && typeof arg.Host === 'string'
                && typeof arg.Path === 'string';
        }
        Url.is = is;
        function toString(url) {
            var Scheme = url.Scheme, Host = url.Host, Path = url.Path;
            return Scheme + "://" + Host + Path;
        }
        Url.toString = toString;
    })(Url = DaemonLog.Url || (DaemonLog.Url = {}));
    var System;
    (function (System) {
        function toString(system) {
            return "OS: " + system.os;
        }
        System.toString = toString;
    })(System = DaemonLog.System || (DaemonLog.System = {}));
    var Tool;
    (function (Tool) {
        function is(arg) {
            return !!arg && typeof arg.version === 'string' && 'systems' in arg;
        }
        Tool.is = is;
        function toString(tool) {
            var version = tool.version, systems = tool.systems;
            return "Version: " + version + (!!systems ? " Systems: [" + tool.systems.map(System.toString).join(', ') + "]" : '');
        }
        Tool.toString = toString;
    })(Tool = DaemonLog.Tool || (DaemonLog.Tool = {}));
    function is(arg) {
        return !!arg
            && typeof arg.time === 'string'
            && typeof arg.level === 'string'
            && typeof arg.msg === 'string';
    }
    DaemonLog.is = is;
    function toLogLevel(log) {
        var level = log.level;
        switch (level) {
            case 'trace': return logger_1.LogLevel.TRACE;
            case 'debug': return logger_1.LogLevel.DEBUG;
            case 'info': return logger_1.LogLevel.INFO;
            case 'warning': return logger_1.LogLevel.WARN;
            case 'error': return logger_1.LogLevel.ERROR;
            default: return logger_1.LogLevel.INFO;
        }
    }
    DaemonLog.toLogLevel = toLogLevel;
    function log(logger, logMessages) {
        var e_1, _a;
        var parsed = parse(logMessages);
        try {
            for (var parsed_1 = __values(parsed), parsed_1_1 = parsed_1.next(); !parsed_1_1.done; parsed_1_1 = parsed_1.next()) {
                var log_1 = parsed_1_1.value;
                var logLevel = toLogLevel(log_1);
                var message = toMessage(log_1, { omitLogLevel: true });
                logger.log(logLevel, message);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (parsed_1_1 && !parsed_1_1.done && (_a = parsed_1.return)) _a.call(parsed_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    DaemonLog.log = log;
    function parse(toLog) {
        var messages = toLog.trim().split('\n');
        var result = [];
        for (var i = 0; i < messages.length; i++) {
            try {
                var maybeDaemonLog = JSON.parse(messages[i]);
                if (DaemonLog.is(maybeDaemonLog)) {
                    result.push(maybeDaemonLog);
                    continue;
                }
            }
            catch ( /* NOOP */_a) { /* NOOP */ }
            result.push({
                time: new Date().toString(),
                level: 'info',
                msg: messages[i]
            });
        }
        return result;
    }
    function toPrettyString(logMessages) {
        var parsed = parse(logMessages);
        return parsed.map(function (log) { return toMessage(log); }).join('\n') + '\n';
    }
    DaemonLog.toPrettyString = toPrettyString;
    function toMessage(log, options) {
        if (options === void 0) { options = { omitLogLevel: false }; }
        var details = Object.keys(log).filter(function (key) { return key !== 'msg' && key !== 'level' && key !== 'time'; }).map(function (key) { return toDetails(log, key); }).join(', ');
        var logLevel = options.omitLogLevel ? '' : "[" + log.level.toUpperCase() + "] ";
        return "" + logLevel + log.msg + (!!details ? " [" + details + "]" : '');
    }
    function toDetails(log, key) {
        var value = log[key];
        if (DaemonLog.Url.is(value)) {
            value = DaemonLog.Url.toString(value);
        }
        else if (DaemonLog.Tool.is(value)) {
            value = DaemonLog.Tool.toString(value);
        }
        else if (typeof value === 'object') {
            value = JSON.stringify(value).replace(/\"([^(\")"]+)\":/g, '$1:'); // Remove the quotes from the property keys.
        }
        return key.toLowerCase() + ": " + value;
    }
})(DaemonLog = exports.DaemonLog || (exports.DaemonLog = {}));
//# sourceMappingURL=daemon-log.js.map